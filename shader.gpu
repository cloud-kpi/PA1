const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
attribute vec2 tex;           // Texture coordinates
attribute vec3 tangent;       // Tangent vector

uniform mat4 ModelViewProjectionMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 NormalMatrix;
uniform mediump vec2 pivot_coords;
uniform mat3 tex_new;

varying vec3 fragTangent;
varying vec3 fragBitangent;
varying vec3 fragNormal;
varying vec3 fragPosition;
varying vec2 tex_pos;      // Transformed texture coordinates


void main() {
	vec3 newTex = tex_new * vec3(tex - pivot_coords, 1.0); // Apply scaling/rotation
    tex_pos = newTex.xy + pivot_coords;
	
	
    vec4 position = ModelViewMatrix * vec4(vertex, 1.0);
    fragPosition = position.xyz;

    fragNormal = normalize((NormalMatrix * vec4(normal, 0.0)).xyz);
    fragTangent = normalize((NormalMatrix * vec4(tangent, 0.0)).xyz);
    fragBitangent = normalize(cross(fragNormal, fragTangent));

    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
}
`;

const fragmentShaderSource = `
precision mediump float;

uniform sampler2D iTMU0;       // Diffuse map
uniform sampler2D iTMU1;       // Specular map
uniform sampler2D iTMU2;       // Normal map

uniform vec3 lightPosition;    // Static light position in world space
uniform vec3 ambientLight;     // Ambient light intensity
uniform vec4 color;            // Surface base color
uniform vec3 viewPosition;     // Camera position in world space

uniform vec2 pivot_coords;          // Pivot point in texture space
uniform float pivot_r;   // Radius of the pivot point marker

varying vec3 fragTangent;
varying vec3 fragBitangent;
varying vec3 fragNormal;      // Interpolated normal from vertex shader
varying vec3 fragPosition;    // Interpolated position from vertex shader
varying vec2 tex_pos;      // Interpolated texture coordinates

void main() {
    // Transform normal map from texture to tangent space
    vec3 tangent = normalize(fragTangent);
    vec3 bitangent = normalize(fragBitangent);
    vec3 norm = normalize(fragNormal);

    mat3 TBN = mat3(tangent, bitangent, norm);

    vec3 normalMap = normalize(texture2D(iTMU2, tex_pos).rgb * 2.0 - 1.0);
	vec3 perturbedNormal = normalize(TBN * normalMap) + vec3(0.5);

    // Calculate lighting
    vec3 lightDir = normalize(lightPosition - fragPosition);
    vec3 viewDir = normalize(viewPosition - fragPosition);

    // Ambient light
    vec3 ambient = ambientLight * color.rgb;

    // Diffuse light
    float diff = max(dot(perturbedNormal, lightDir), 0.2);
    vec3 diffuse = diff * texture2D(iTMU0, tex_pos).rgb;

    // Specular light
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(perturbedNormal, halfwayDir), 0.0), 16.0);
    vec3 specular = texture2D(iTMU1, tex_pos).rgb * spec;

    // Final color
    vec3 finalColor = ambient + diffuse + specular;

	if (length(tex_pos - pivot_coords) - 0.01 < pivot_r) 
		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
	else 
		gl_FragColor = vec4(finalColor, color.a);
}
`;
